# NestJS Request Life Cycle

요청이 디바이스로부터 서버로 보내진 다음에 응답이 되어서 돌아오는 과정이다.

공식문서에서는 아래와 같은 순서로 응답이 진행된다고 적혀있다.

1. 들어오는 요청
2. 미들웨어
   - 전역적으로 바인딩 된 미들웨어
   - 모듈 바인딩 미들웨어
3. 가드
   - 글로벌 가드
   - 컨트롤러 가드
   - 라우트 가드
4. 컨트롤러 이전 인터셉터
   - 글로벌 인터셉터(컨트롤러 이전)
   - 컨트롤러 인터셉터(컨트롤러 이전)
   - 라우트 인터셉터(컨트롤러 이전)
5. 파이프
   - 글로벌 파이프
   - 컨트롤러 파이프
   - 라우트 파이프
   - 매개변수 파이프 경로 지정
6. 컨트롤러(메서드 핸들러)
7. 서비스(존재하는 경우)
8. 요청 후 인터셉터
   - 라우트 인터셉터(요청 후)
   - 컨트롤러 인터셉터(요청 후)
   - 전역 인터셉터(요청 후)
9. 예외 필터(라우트, 컨트롤러, 전역)
10. 서버 응답

[NestJS 공식문서 Request Life Cycle 링크](https://docs.nestjs.com/faq/request-lifecycle)

글로만봐서는 한눈에 들어오지 않는다. 아래는 이를 표현한 그림이다.

<img width="1073" alt="스크린샷 2024-03-04 오후 2 18 43" src="https://github.com/munyeol-Yoon/DC-day1-document/assets/50113066/a3043775-f92e-4091-aefe-13b50ca10a35">

### 1. Middleware

전역적으로 바인딩 되어 있는 미들웨어를 가장 먼저 실행한다.

ex) main.ts애 app.use 로 바인딩 되어 있는 미들웨어들

기본적으로 express의 미들웨어와 동일하다.

express 에 문서에는 미들웨어가 다음과 같은 동작을 수행할 수 있다고 기술되어 있다.

- 어떤 형태의 코드라도 수행할 수 있다.
- 요청과 응답에 변형을 가할 수 있다.
- 요청/응답 주기를 끝낼 수 있다.
- 여러 개의 미들웨어를 사용한다면 next()로 호출 스택상 다음 미들웨어에 제어권을 전달한다.

미들웨어가 응답주기를 끝내지 않을 것이라면 반드시 next()를 호출해야한다. 그렇지 않으면 애플리케이션은 아무것도 할 수 없는 상태가 된다.

**Q. 어디에 활용할 수 있을까?**

- 쿠키 파싱 : 쿠키를 파싱하여 사용하기 쉬운 데이터 구조로 변경, 이를 활용해 라우터 핸들러가 매번 쿠키를 파싱할 필요가 없어진다.
- 세션 관리 : 세션 쿠키를 찾고, 해당 쿠키에 대한 세션의 상태를 조회해서 요청에 세션 정보를 추가한다. 이를 통해 다른 핸들러가 세션 객체를 이용할 수 있게 해준다.
- 인증/인가 : 사용자가 서비스에 접근 가능한 권한이 있는지 확인한다. **단 NestJS는 인가를 구현할때 가드를 이용하도록 권장한다.**
- 본문 파싱 : 본문은 POST/PUT 요청으로 들어오는 JSON 타입 뿐 아니라 파일 스트림과 같은 데이터도 있다. 이 데이터를 유형에 따라 읽고 해석한 다음 매개변수에 넣는 작업을 한다.

또 원하는 기능이 있다면 직접 구현도 가능하다.

### 2. Guard

사용자의 권한을 체크하는 로직이 들어간다. 예를 들어 JWT를 사용한다면 @UseGuards() 를 통해 JWT 의 값이 유효한지 검사할 수 있다.

**Q. 어디에 활용할 수 있을까?**

- 인증은 미들웨어로 구현하는 것이 좋은 사례이다. 추가적으로 인가를 구현해야하는데 이는 Guard 를 통해 구현하는 것이 좋다.

**Q. 왜 인가는 미들웨어로 구현하면 안될까?**

- 미들웨어는 실행 컨텍스트(ExecutionContext)에 접근할 수 없다. 단순히 자신의 일만 수행하고 next()를 호출한다. 즉, 다음에 어떤 핸들러가 실행될지 알 수 없고, 이에 반해 Guard 는 실행 컨텍ㄷ스트 인스턴스에 접근할 수 있어 다음 실행될 작업을 정확히 알고 있기 때문이다.

### 3. Interceptor

인터셉터는 컨트롤러에 접근하기 전, 후에서 바인딩 시킬 수 있다.

컨트롤러에 접근하기 전에 사용하려면 return 전에, 컨트롤러 접근 후에 사용하려면 return 문에 사용하면 된다.

- 대부분의 Interceptor 는 Guard 와 동일하다. 단, Interceptor 가 RxJS Observables 를 반환하면 옵저버블은 선입선출 방식으로 해결(Resolve) 한다.
- 인바운드 요청은 표준 전역, 컨트롤러, 라우터를 거치고, 요청에 대한 응답은 라우터, 컨트롤러, 전역 순서이다.
- 파이프, 컨트롤러 또는 서비스에서 발생하는 모든 오류는 인터셉터의 catchError 에서 읽을 수 있다.

### 4. Pipe

요청이 들어오는 파라미터의 validation 혹은 형변환이 필요할 때 파이프에서 진행된다.

- 매개변수와 관련하려 선입선출이다. 경계 시퀀스를 라우팅하기 위해 컨트롤러에 대한 표준 전역을 따른다.
- 라우트 파라미터 수준에서 여러 파이프가 실행중인 경우 첫 번째 매개변수 부터 마지막 매개변수의 순서로 실행된다.
- 이는 라우트 수준, 컨트롤러 수준 파이프에서도 적용된다.

### 5. controller

routing, http method, Request 에 담긴 페이로드, Response 에 담을 페이로드를 Controller 에서 관리 할 수 있다.

### 6. Service

실제 비즈니스 로직을 Service 단에서 관리할 수 있다.

### 7. Exception Filter

Exception Filter 는 로직을 처리하다가 오류가 발생하면 HttpException 을 throw 하게 된다.

- 필터는 전역 먼저 확인하지 않는 유일한 구성요소이다. 가능한 가장 낮은 수준에서 해결(Resolve)한다. 라우트에서 컨트롤러, 마지막으로 전역 필터로 진행된다.
- 그러나 필터에서 필터로 예외를 전달할 수는 없다.
- 라우터 수준 필터가 예외를 포착하면 컨트롤러 또는 전역 필터가 동일한 예외를 포착할 수 없고, 이와 같은 효과를 얻는 유일한 방법은 필터간에 상속을 사용하는 것이다.
